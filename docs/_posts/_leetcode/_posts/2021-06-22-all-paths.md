---
layout: post
title: "All Paths From Source to Target"
date: 2021-06-22 12:00:00 -0000
categories: leetcode medium algorithms graph dfs dag
---

**Problem 797**

Given a directed acyclic graph of `n` nodes labeled from 0 to `n - 1`, find all possible paths from node `0` to node `n - 1`, and return them in any order.

The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).

#### Solution

I struggled with this, and in all honesty, I had to look up the answer.

I noticed a lot of solutions used either nested or helper functions, but the best solution I came across was [this](https://leetcode.com/problems/all-paths-from-source-to-target/discuss/898747/Easy-Python-using-deque).

The code below is my own take on it, but obviously, all the credit goes to [umeshbodhwani](https://leetcode.com/umeshbodhwani/). I wish I had found this.

I want to walk through the algorithm.

So, `n` is the graph length, obviously, and we intantiate our `stack` and a `paths` array (which will become a list of lists).

Append a list containing the source node (in this case, `0`) to `stack`.

While `stack` is not empty, pop the left most value, which will be a list. 

If the last value in this list is the target (`n - 1`), then append this list to `paths` because this list begins with the source and contains a path to the target, which is the last value in the list.

Now, whether that value is the target or not, for each neighbor of that node, we append to `stack` the list that node currently resides at the end of (`u`), concatenated with a list containing the neighbor.

The question becomes, what prevents the algorithm from push a list onto the stack that contains duplicate values? And the answer is... I don't know.

```python
class Solution(object):
    def allPathsSourceTarget(self, graph):
        n = len(graph)
        paths = []
        stack = []
        stack.append([0])
        while stack:
            u = stack.pop(0)
            if u[-1] == n - 1:
                paths.append(u)
            for v in graph[u[-1]]:
                stack.append(u + [v])
        return paths
```

[Leetcode submission](https://leetcode.com/submissions/detail/519429815/)



